<!DOCTYPE html>
<html lang="en-us">
	<head>
		<link href="visualizer.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<div id="wrapper" position=absolute>
			<canvas id="c" class="visualizer"></canvas> 
		</div>

	</body>

</html>

<script>
	var audioContext = new (window.AudioContext || window.webkitAudioContext)();
var source;
var stream;

var refreshRate = 10;
var analyser = audioContext.createAnalyser();

var canvas = document.getElementById("c");
var cc = canvas.getContext("2d");

var deltaTime;
var curTime;
var prevTime;
var curVis = 0;	
var cancelVis;
var currentVisualizerIndex = 0;
var visualizations = [frequencyBars,polygon];//ADD YOUR FUNCTION NAME TO THIS LIST
var HEIGHT;
var WIDTH;


if (navigator.mediaDevices.getUserMedia) {
	console.log('getUserMedia supported.');
	var constraints = {audio: true}
	navigator.mediaDevices.getUserMedia (constraints).then(function(stream) {
		source = audioContext.createMediaStreamSource(stream);
		source.connect(analyser);
		//setTimeout(visualize, 1000);
		console.log(canvas.width, canvas.height);
		updateVis();
	})
		.catch( function(err) { console.log('The following gUM error occured: ' + err);})
} else {
	console.log('getUserMedia not supported on your browser!');
}
//this function gets called every time a new animation is selected
function updateVis(){
	console.log("updating visualization");
	let deltaTime = (new Date).getTime() - curTime;
	curTime = (new Date).getTime();
	HEIGHT = canvas.height;
	WIDTH  = canvas.width;
	//currentVisualizerIndex = 0

	visualizations[currentVisualizerIndex](deltaTime);
}
//ignore this, just a doodle
function drawSin(rate){
	//console.log("A");
	cc.fillStyle = "black";
	cc.fillRect(0,0,canvas.width,canvas.height);
	cc.strokeStyle = "white";
	cc.beginPath();
	cc.moveTo(0,canvas.height/2);
	for(i = 1; i < canvas.width; i++){
		//sin input range is -pi/2 to pi/2
		var y = canvas.height/2 + Math.sin(i/10 + (deltaTime/10.0))*canvas.height/4;
		//console.log(y)
		cc.lineTo(i, y)
	}
	cc.stroke();
}

//function drawFrequency(deltaTime)
//this is one of many visualizers you can pick. The function is chosen, it sets up relavent data, declares the function to animate the visualization, and sets up a callback to call the function every frame with requestAnimationFrame.
function frequencyBars(){
	console.log("frequencyBars");
	analyser.fftSize = 2048;
	analyser.minDecibels = -90;
	analyser.maxDecibels = -10;
	analyser.smoothingTimeConstant = .1;
	
	var bufferLengthAlt = analyser.frequencyBinCount;//fftsize/2
	console.log(bufferLengthAlt);
	var dataArrayAlt = new Uint8Array(bufferLengthAlt);
	
	cc.clearRect(0, 0, WIDTH, HEIGHT);

	var drawFrequencyBars = function() {
		cancelVis = requestAnimationFrame(drawFrequencyBars);

		analyser.getByteFrequencyData(dataArrayAlt);

		cc.fillStyle = 'rgb(0, 0, 0)';
		cc.fillRect(0, 0, WIDTH, HEIGHT);

		var barWidth = (WIDTH / bufferLengthAlt) * 2.5;
		var barHeight;
		var x = 0;
		
		for(var i = 0; i < bufferLengthAlt; i++) {
			barHeight = dataArrayAlt[i];
			
	//i want to try boosting the bass for no good reason, like a deejay
			
			bassCoeff = dataArrayAlt.length - i
			cc.fillStyle = 'rgb(200,20,200)';
			//cc.fillRect(x,HEIGHT-barHeight,barWidth,barHeight);
			cc.fillRect(x, HEIGHT/2 - barHeight, barWidth, barHeight * 2);
			x += barWidth + 1;
		}
	};

	drawFrequencyBars();
}		

function polygon(data){
	console.log("polygon");
	analyser.fftSize = 2048;
	analyser.smoothingTimeConstant = .5;

	var bufferLengthAlt = analyser.frequencyBinCount;
	var dataArrayAlt = new Uint8Array(bufferLengthAlt);
	cc.clearRect(0,0,WIDTH,HEIGHT)
	var drawPolygon = function(){
		cancelVis = requestAnimationFrame(drawPolygon);
		analyser.getByteFrequencyData(dataArrayAlt);
		cc.fillStyle = 'rgb(0,0,0)';
		cc.fillRect(0,0,WIDTH,HEIGHT);
		
		cc.strokeStyle = 'rgb(200,20,200)';
		cc.strokeWidth = 5;
		cc.beginPath();
		cc.moveTo(WIDTH/2,HEIGHT/2);
	
		let angleIncrement = 2.0 * Math.PI/bufferLengthAlt
		let minRad = 5;
		for(i = 0; i < bufferLengthAlt; i++){			
			deltaRad = dataArrayAlt[i]
			rad = minRad + deltaRad

			x = WIDTH /2 + rad * Math.cos(angleIncrement * i)
			y = HEIGHT/2 + rad * Math.sin(angleIncrement * i)

			cc.lineTo(x, y)
		}
		cc.stroke();
	};
	drawPolygon();

}



window.onkeyup = (e) => {
	let key = e.keyCode
	if(key == 37){
		currentVisualizerIndex--;
		if(currentVisualizerIndex < 0){
			currentVisualizerIndex = visualizations.length - 1
		}
		console.log("current vis index updated to: " + currentVisualizerIndex);
		window.cancelAnimationFrame(cancelVis);
		updateVis();
	}
	else if(key == 39){	
		currentVisualizerIndex++;
		if(currentVisualizerIndex > visualizations.length - 1){
			currentVisualizerIndex = 0
		}
		console.log("current vis index updated to: " + currentVisualizerIndex);
		window.cancelAnimationFrame(cancelVis);
		updateVis();
	}
}

window.onresize = () => {
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	HEIGHT = canvas.height
	WIDTH = canvas.width
	document.body.style.overflow = 'hidden';
}	


window.onresize()
curTime = (new Date).getTime();
cancelVis = requestAnimationFrame(updateVis);
</script>
