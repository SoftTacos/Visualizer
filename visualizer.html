<!DOCTYPE html>
<html lang="en-us">
	<head>
		<link href="visualizer.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<div id="myNav" class="overlay">
			<!-- Button to close the overlay navigation -->
			<a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
			<!-- Overlay content -->
			<div id="menu" class="overlay-content">
				<a href="#">About</a>
				<a href="#">Services</a>
				<a href="#">Clients</a>
				<a href="#">Contact</a>
			</div>

		</div>
		<div id="wrapper" position=absolute onclick="openNav()">
			<canvas id="c" class="visualizer"></canvas>
		</div>

	</body>

</html>

<script>
	var audioContext = new (window.AudioContext || window.webkitAudioContext)();
var source;
var stream;

var refreshRate = 10;
var analyser = audioContext.createAnalyser();

var menu = document.getElementById("menu");
var canvas = document.getElementById("c");
var cc = canvas.getContext("2d");

var deltaTime;
var curTime;
var prevTime;
var curVis = 0;	
var cancelVis;
var currentVisualizerIndex = 0;
var visualizations = [frequencyBars,circle];//ADD YOUR FUNCTION NAME TO THIS LIST
var HEIGHT;
var WIDTH;


if (navigator.mediaDevices.getUserMedia) {
	console.log('getUserMedia supported.');
	var constraints = {audio: true}
	navigator.mediaDevices.getUserMedia (constraints).then(function(stream) {
		source = audioContext.createMediaStreamSource(stream);
		source.connect(analyser);
		//setTimeout(visualize, 1000);
		console.log(canvas.width, canvas.height);
		updateVis();
	})
		.catch( function(err) { console.log('The following gUM error occured: ' + err);})
} else {
	console.log('getUserMedia not supported on your browser!');
}
//this function gets called every time a new animation is selected
function updateVis(){
	console.log("updating visualization");
	let deltaTime = (new Date).getTime() - curTime;
	curTime = (new Date).getTime();
	HEIGHT = canvas.height;
	WIDTH  = canvas.width;
	//currentVisualizerIndex = 0

	visualizations[currentVisualizerIndex]();
}
//ignore this, just a doodle
function drawSin(rate){
	//console.log("A");
	cc.fillStyle = "black";
	cc.fillRect(0,0,canvas.width,canvas.height);
	cc.strokeStyle = "white";
	cc.beginPath();
	cc.moveTo(0,canvas.height/2);
	for(i = 1; i < canvas.width; i++){
		//sin input range is -pi/2 to pi/2
		var y = canvas.height/2 + Math.sin(i/10 + (deltaTime/10.0))*canvas.height/4;
		//console.log(y)
		cc.lineTo(i, y)
	}
	cc.stroke();
}


//this is one of many visualizers you can pick. The function is chosen, it sets up relavent data, declares the function to animate the visualization, and sets up a callback to call the function every frame with requestAnimationFrame.
function frequencyBars(){
	console.log("frequencyBars");
	//clearing the current menu and adding options for this visualization

	while(menu.lastChild){
		menu.removeChild(menu.lastChild);
	}
	
	var barColor = '#FFFFFF';
	var RGBInput = document.createElement("input");
	RGBInput.value = barColor;
	menu.appendChild(RGBInput)
	RGBInput.oninput = () =>{
		if(RegExp('#([0-9]|[a-f]|[A-F]){6}').test(RGBInput.value)){
			barColor = RGBInput.value
		}
	}
	
	
	analyser.fftSize = 2048;
	analyser.minDecibels = -90;
	analyser.maxDecibels = -10;
	analyser.smoothingTimeConstant = .1;

	var bufferLengthAlt = analyser.frequencyBinCount;//fftsize/2
	console.log(bufferLengthAlt);
	var dataArrayAlt = new Uint8Array(bufferLengthAlt);

	cc.clearRect(0, 0, WIDTH, HEIGHT);

	var drawFrequencyBars = function() {
		cancelVis = requestAnimationFrame(drawFrequencyBars);

		analyser.getByteFrequencyData(dataArrayAlt);

		cc.fillStyle = '#000000';
		cc.fillRect(0, 0, WIDTH, HEIGHT);

		var barWidth = (WIDTH / bufferLengthAlt) * 2.5;
		var barHeight;
		var x = 0;

		for(var i = 0; i < bufferLengthAlt; i++) {
				  barHeight = dataArrayAlt[i];

				  //i want to try boosting the bass for no good reason, like a deejay
				
				  bassCoeff = dataArrayAlt.length - i
				  cc.fillStyle = barColor;//'rgb(200,20,200)';
				  //cc.fillRect(x,HEIGHT-barHeight,barWidth,barHeight);
				  cc.fillRect(x, HEIGHT/2 - barHeight, barWidth, barHeight * 2);
				  x += barWidth + 1;
				  }
				  };

				  drawFrequencyBars();
				  }		

				  function circle(){
				  console.log("circle");
				  analyser.fftSize = 2048;
				  analyser.smoothingTimeConstant = .5;

				  //leaving code for fields in here until i've got a better idea what works

var bufferLengthAlt = analyser.frequencyBinCount;
var dataArrayAlt = new Uint8Array(bufferLengthAlt);
cc.clearRect(0,0,WIDTH,HEIGHT)
var drawCircle = function(){

cancelVis = requestAnimationFrame(drawCircle);

analyser.getByteFrequencyData(dataArrayAlt);
cc.fillStyle = 'rgb(0,0,0)';
cc.fillRect(0,0,WIDTH,HEIGHT);

cc.strokeStyle = 'rgb(200,20,200)';
cc.lineWidth = 2;
cc.beginPath();
cc.moveTo(WIDTH/2,HEIGHT/2);

let angleIncrement = 2.0 * Math.PI/(bufferLengthAlt)
let minRad = 5;
for(i = 0; i < bufferLengthAlt; i++){			
deltaRad = dataArrayAlt[i]
rad = minRad + deltaRad

x = WIDTH /2 + rad * Math.cos(angleIncrement * i)
y = HEIGHT/2 + rad * Math.sin(angleIncrement * i)

cc.lineTo(x, y)
}
cc.stroke();
};
drawCircle();
}



window.onkeyup = (e) => {
let key = e.keyCode
if(key == 32){//space bar
console.log("toggle menu");//TODO: make space also close the menu
openNav();
}
else if(key == 37){
currentVisualizerIndex--;
if(currentVisualizerIndex < 0){
currentVisualizerIndex = visualizations.length - 1
}
console.log("current vis index updated to: " + currentVisualizerIndex);
window.cancelAnimationFrame(cancelVis);
updateVis();
closeNav();
}
else if(key == 39){	
currentVisualizerIndex++;
if(currentVisualizerIndex > visualizations.length - 1){
currentVisualizerIndex = 0
}
console.log("current vis index updated to: " + currentVisualizerIndex);
window.cancelAnimationFrame(cancelVis);
updateVis();
closeNav();
}
}

window.onresize = () => {
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
HEIGHT = canvas.height
WIDTH = canvas.width
document.body.style.overflow = 'hidden';
}

/* Open when someone clicks on the span element */
function openNav() {
document.getElementById("myNav").style.width = "100%";
}

/* Close when someone clicks on the "x" symbol inside the overlay */
function closeNav() {
document.getElementById("myNav").style.width = "0%";
}


window.onresize()
curTime = (new Date).getTime();
cancelVis = requestAnimationFrame(updateVis);
</script>
